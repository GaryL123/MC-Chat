"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeSelectors = void 0;
function normalizeSelectors(extractedStyle, selectorList, options, selectors = [], defaults = {}) {
    for (let cssSelector of selectorList) {
        if (isIsPseudoClass(cssSelector)) {
            normalizeSelectors(extractedStyle, cssSelector[0].selectors, options, selectors);
            continue;
        }
        if (isRootVariableSelector(cssSelector)) {
            if (isDarkModeMediaQuery(extractedStyle.media?.[0])) {
                selectors.push({
                    type: "rootVariables",
                    subtype: "dark",
                });
            }
            else {
                selectors.push({
                    type: "rootVariables",
                    subtype: "light",
                });
            }
            continue;
        }
        if (isRootDarkVariableSelector(cssSelector, options)) {
            selectors.push({
                type: "rootVariables",
                subtype: "dark",
            });
            continue;
        }
        if (isDefaultVariableSelector(cssSelector)) {
            if (isDarkModeMediaQuery(extractedStyle.media?.[0])) {
                selectors.push({
                    type: "universalVariables",
                    subtype: "dark",
                });
            }
            else {
                selectors.push({
                    type: "universalVariables",
                    subtype: "light",
                });
            }
            continue;
        }
        if (isDarkDefaultVariableSelector(cssSelector, options)) {
            selectors.push({
                type: "universalVariables",
                subtype: "dark",
            });
            continue;
        }
        if (isDarkClassSelector(cssSelector, options)) {
            const [_, __, third, ...rest] = cssSelector;
            normalizeSelectors(extractedStyle, [[third, ...rest]], options, selectors, {
                darkMode: true,
            });
            continue;
        }
        let isValid = true;
        const selector = {
            ...defaults,
            type: "className",
            className: "",
            specificity: { A: 0, B: 0, C: 0 },
        };
        let previousWasCombinator = true;
        for (const component of cssSelector) {
            switch (component.type) {
                case "universal":
                case "namespace":
                case "nesting":
                    isValid = false;
                    break;
                case "id":
                    selector.specificity.A++;
                    isValid = false;
                    break;
                case "attribute": {
                    if (!selector.className) {
                        isValid = false;
                        break;
                    }
                    selector.specificity.B++;
                    selector.attrs ??= [];
                    if (component.name.startsWith("data-")) {
                        selector.attrs.push({
                            ...component,
                            type: "data-attribute",
                        });
                    }
                    else {
                        selector.attrs.push(component);
                    }
                    break;
                }
                case "pseudo-element":
                    selector.specificity.C++;
                    isValid = false;
                    break;
                case "type": {
                    selector.specificity.C++;
                    isValid = component.name === options.selectorPrefix;
                    break;
                }
                case "combinator": {
                    if (component.value !== "descendant") {
                        isValid = false;
                    }
                    else {
                        previousWasCombinator = true;
                    }
                    break;
                }
                case "class": {
                    if (!previousWasCombinator) {
                        isValid = false;
                        break;
                    }
                    selector.specificity.B++;
                    if (selector.className) {
                        const groupingValid = options.grouping.some((group) => {
                            return group.test(selector.className);
                        });
                        if (!groupingValid) {
                            isValid = false;
                        }
                        else {
                            selector.groupClassName = selector.className;
                            selector.className = component.name;
                            selector.groupPseudoClasses = selector.pseudoClasses;
                            selector.pseudoClasses = {};
                        }
                    }
                    else if (component.name === options.selectorPrefix?.slice(1)) {
                        break;
                    }
                    else {
                        selector.className = component.name;
                    }
                    break;
                }
                case "pseudo-class": {
                    if (!selector.className) {
                        isValid = false;
                        break;
                    }
                    selector.specificity.B++;
                    switch (component.kind) {
                        case "hover":
                        case "active":
                        case "focus":
                            selector.pseudoClasses ??= {};
                            selector.pseudoClasses[component.kind] = true;
                            break;
                        case "disabled":
                            selector.attrs ??= [];
                            selector.attrs.push({ type: "attribute", name: "disabled" });
                            break;
                        case "empty":
                            selector.attrs ??= [];
                            selector.attrs.push({
                                type: "attribute",
                                name: "children",
                                operation: { operator: "empty" },
                            });
                            break;
                    }
                }
            }
            if (!isValid) {
                break;
            }
        }
        if (!isValid) {
            continue;
        }
        selectors.push(selector);
    }
    return selectors;
}
exports.normalizeSelectors = normalizeSelectors;
function isIsPseudoClass(selector) {
    return (selector.length === 1 &&
        selector[0].type === "pseudo-class" &&
        selector[0].kind === "is");
}
function isDarkModeMediaQuery(query) {
    return Boolean(query?.condition &&
        query.condition.type === "feature" &&
        query.condition.value.type === "plain" &&
        query.condition.value.name === "prefers-color-scheme" &&
        query.condition.value.value.value === "dark");
}
function isDarkClassSelector([first, second, third], options) {
    return (options.darkMode?.type === "class" &&
        first &&
        second &&
        third &&
        first.type === "class" &&
        first.name === options.darkMode?.value &&
        second.type === "combinator" &&
        second.value === "descendant" &&
        third.type === "class");
}
function isRootVariableSelector([first, second]) {
    return (first && !second && first.type === "pseudo-class" && first.kind === "root");
}
function isDefaultVariableSelector([first, second]) {
    return first && !second && first.type === "universal";
}
function isRootDarkVariableSelector([first, second], options) {
    return (options.darkMode?.type === "class" &&
        first.type === "class" &&
        first.name === options.darkMode.value &&
        second &&
        second.type === "pseudo-class" &&
        second.kind === "root");
}
function isDarkDefaultVariableSelector([first, second, third], options) {
    return (options.darkMode?.type === "class" &&
        first &&
        second &&
        third &&
        first.type === "class" &&
        first.name === options.darkMode.value &&
        second.type === "combinator" &&
        second.value === "descendant" &&
        third.type === "universal");
}
//# sourceMappingURL=normalize-selectors.js.map