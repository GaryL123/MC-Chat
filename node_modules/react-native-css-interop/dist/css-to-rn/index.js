"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cssToReactNativeRuntime = void 0;
const lightningcss_1 = require("lightningcss");
const shared_1 = require("../shared");
const parseDeclaration_1 = require("./parseDeclaration");
const normalize_selectors_1 = require("./normalize-selectors");
function cssToReactNativeRuntime(code, options = {}) {
    const grouping = options.grouping?.map((value) => {
        return typeof value === "string" ? new RegExp(value) : value;
    }) ?? [];
    const extractOptions = {
        darkMode: { type: "media" },
        declarations: new Map(),
        keyframes: new Map(),
        rootVariables: {},
        universalVariables: {},
        flags: {},
        appearanceOrder: 0,
        rem: { light: 14, dark: 14 },
        ...options,
        grouping,
    };
    (0, lightningcss_1.transform)({
        filename: "style.css",
        code: typeof code === "string" ? Buffer.from(code) : code,
        visitor: {
            Rule(rule) {
                extractRule(rule, extractOptions);
                return [];
            },
        },
        customAtRules: {
            cssInterop: {
                prelude: "<custom-ident>+",
            },
            "rn-hoist": {
                prelude: "<custom-ident>+",
            },
            "rn-move": {
                prelude: "<custom-ident>+",
            },
        },
    });
    const declarations = [];
    for (const [name, styles] of extractOptions.declarations) {
        if (styles.length > 0) {
            const grouped = { scope: shared_1.STYLE_SCOPES.SELF };
            for (const { props, propSingleValue, warnings, ...rest } of styles) {
                const transportStyle = rest;
                transportStyle.props = Object.entries(props)
                    .filter(([key]) => propSingleValue[key] === undefined)
                    .map(([key, value]) => {
                    if (value["$$type"] === "prop") {
                        return [key, value];
                    }
                    else {
                        return [key, Object.entries(value)];
                    }
                });
                transportStyle.props.push(...Object.entries(propSingleValue));
                if (transportStyle.specificity.I) {
                    grouped[2] ??= [];
                    grouped[2].push(transportStyle);
                }
                else {
                    grouped[0] ??= [];
                    grouped[0].push(transportStyle);
                }
                if (warnings) {
                    grouped.warnings ??= [];
                    grouped.warnings.push(...warnings);
                }
            }
            if (grouped[0]?.length || grouped[2]?.length) {
                declarations.push([name, grouped]);
            }
        }
    }
    return {
        declarations,
        keyframes: Object.fromEntries(extractOptions.keyframes),
        rootVariables: extractOptions.rootVariables,
        universalVariables: extractOptions.universalVariables,
        flags: extractOptions.flags,
        rem: extractOptions.rem,
    };
}
exports.cssToReactNativeRuntime = cssToReactNativeRuntime;
function extractRule(rule, extractOptions, partialStyle = {}) {
    switch (rule.type) {
        case "keyframes": {
            extractKeyFrames(rule.value, extractOptions);
            break;
        }
        case "container": {
            extractedContainer(rule.value, extractOptions);
            break;
        }
        case "media": {
            extractMedia(rule.value, extractOptions);
            break;
        }
        case "style": {
            if (rule.value.declarations) {
                for (const style of getExtractedStyles(rule.value.declarations, extractOptions, getStyleMapping(rule.value.rules))) {
                    setStyleForSelectorList({ ...partialStyle, ...style }, rule.value.selectors, extractOptions);
                }
                extractOptions.appearanceOrder++;
            }
            break;
        }
        case "custom": {
            if (rule.value && rule.value?.name === "cssInterop") {
                extractCSSInteropFlag(rule, extractOptions);
            }
        }
    }
}
function getStyleMapping(rules) {
    if (!rules)
        return {};
    const mapping = {};
    for (const rule of rules) {
        if (rule.type !== "custom")
            continue;
        switch (rule.value.name) {
            case "rn-hoist": {
                const components = rule.value.prelude.value.components.map((c) => {
                    return c.value;
                });
                if (components.length === 0) {
                    mapping["*"] = { hoist: toRNProperty(components[0]) };
                }
                else if (components.length === 1) {
                    mapping[components[0]] = { hoist: toRNProperty(components[0]) };
                }
                else if (components.length === 2) {
                    mapping[components[0]] = { hoist: toRNProperty(components[1]) };
                }
                break;
            }
            case "rn-move": {
                const components = rule.value.prelude.value.components.map((c) => {
                    return c.value;
                });
                if (components.length === 1) {
                    mapping["*"] = { prop: toRNProperty(components[0]) };
                }
                else if (components.length >= 2) {
                    const mappingValue = {
                        prop: toRNProperty(components[1]),
                    };
                    if (components[2]) {
                        mappingValue.attribute = toRNProperty(components[2]);
                    }
                    if (components[3]) {
                        mappingValue.transform = toRNProperty(components[3]);
                    }
                    mapping[components[0]] = mappingValue;
                }
            }
        }
    }
    return mapping;
}
function extractCSSInteropFlag(rule, extractOptions) {
    if (rule.value.prelude.value.components[0].value !== "set") {
        return;
    }
    const [_, name, type, ...other] = rule.value.prelude.value.components.map((c) => c.value);
    if (name === "darkMode") {
        let value;
        if (other.length === 0 || other[0] === "media") {
            extractOptions.darkMode = { type: "media" };
        }
        else {
            value = other[0];
            if (value.startsWith(".")) {
                value = value.slice(1);
                extractOptions.darkMode = { type: "class", value };
            }
            else if (value.startsWith("[")) {
                extractOptions.darkMode = { type: "attribute", value };
            }
            else if (value === "dark") {
                extractOptions.darkMode = { type: "class", value };
            }
        }
        extractOptions.flags.darkMode = `${type} ${value}`.trim();
    }
    else {
        const value = other.length === 0 ? "true" : other;
        extractOptions.flags[name] = value;
    }
}
function extractMedia(mediaRule, extractOptions) {
    const media = [];
    for (const mediaQuery of mediaRule.query.mediaQueries) {
        let isScreen = mediaQuery.mediaType !== "print";
        if (mediaQuery.qualifier === "not") {
            isScreen = !isScreen;
        }
        if (isScreen) {
            media.push(mediaQuery);
        }
    }
    if (media.length === 0) {
        return;
    }
    for (const rule of mediaRule.rules) {
        extractRule(rule, extractOptions, { media });
    }
}
function extractedContainer(containerRule, extractOptions) {
    for (const rule of containerRule.rules) {
        extractRule(rule, extractOptions, {
            containerQuery: [
                {
                    name: containerRule.name,
                    condition: containerRule.condition,
                },
            ],
        });
    }
}
function setStyleForSelectorList(extractedStyle, selectorList, options) {
    const { declarations } = options;
    for (const selector of (0, normalize_selectors_1.normalizeSelectors)(extractedStyle, selectorList, options)) {
        const style = { ...extractedStyle };
        if (selector.type === "rootVariables" ||
            selector.type === "universalVariables") {
            const styleProp = style.props?.style;
            if (typeof styleProp === "object" && "fontSize" in styleProp) {
                options.rem ??= {};
                const fontSize = styleProp.fontSize;
                if (typeof fontSize === "number") {
                    if (selector.subtype === "light") {
                        options.rem.light = fontSize;
                    }
                    else {
                        options.rem.dark = fontSize;
                    }
                }
            }
            if (!style.variables) {
                continue;
            }
            const { type, subtype } = selector;
            const record = (options[type] ??= {});
            for (const [name, value] of style.variables) {
                record[name] ??= {};
                record[name][subtype] = value;
            }
            continue;
        }
        else if (selector.type === "className") {
            const { className, groupClassName, pseudoClasses, groupPseudoClasses, darkMode, attrs, } = selector;
            if (style.props?.style && Object.keys(style.props.style).length === 0) {
                delete style.props.style;
            }
            const specificity = {
                ...extractedStyle.specificity,
                ...selector.specificity,
            };
            if (groupClassName) {
                addDeclaration(groupClassName, {
                    specificity,
                    attrs,
                    props: {},
                    propSingleValue: {},
                    scope: shared_1.STYLE_SCOPES.GLOBAL,
                    container: {
                        names: [groupClassName],
                    },
                }, declarations);
                style.containerQuery ??= [];
                style.containerQuery.push({
                    name: groupClassName,
                    pseudoClasses: groupPseudoClasses,
                });
            }
            if (darkMode) {
                style.media ??= [];
                style.media.push({
                    mediaType: "all",
                    condition: {
                        type: "feature",
                        value: {
                            type: "plain",
                            name: "prefers-color-scheme",
                            value: { type: "ident", value: "dark" },
                        },
                    },
                });
            }
            addDeclaration(className, { ...style, specificity, pseudoClasses, attrs }, declarations);
        }
    }
}
function addDeclaration(className, style, declarations) {
    const existing = declarations.get(className);
    if (existing) {
        existing.push(style);
    }
    else {
        declarations.set(className, [style]);
    }
}
function extractKeyFrames(keyframes, extractOptions) {
    const extractedAnimation = { frames: {} };
    const frames = extractedAnimation.frames;
    let rawFrames = [];
    for (const frame of keyframes.keyframes) {
        if (!frame.declarations.declarations)
            continue;
        const { props, hoistedStyles } = declarationsToStyle(frame.declarations.declarations, {
            ...extractOptions,
            useInitialIfUndefined: true,
            requiresLayout(name) {
                if (name === "rnw") {
                    extractedAnimation.requiresLayoutWidth = true;
                }
                else {
                    extractedAnimation.requiresLayoutHeight = true;
                }
            },
        }, {
            I: 99,
            S: 1,
            O: extractOptions.appearanceOrder,
        }, {});
        if (hoistedStyles) {
            extractedAnimation.hoistedStyles ??= [];
            extractedAnimation.hoistedStyles.push(...hoistedStyles);
        }
        const styleProp = props?.style;
        if (!styleProp || (0, shared_1.isPropDescriptor)(styleProp))
            continue;
        for (const selector of frame.selectors) {
            const keyframe = selector.type === "percentage"
                ? selector.value * 100
                : selector.type === "from"
                    ? 0
                    : selector.type === "to"
                        ? 100
                        : undefined;
            if (keyframe === undefined)
                continue;
            switch (selector.type) {
                case "percentage":
                    rawFrames.push({ selector: selector.value, values: styleProp });
                    break;
                case "from":
                    rawFrames.push({ selector: 0, values: styleProp });
                    break;
                case "to":
                    rawFrames.push({ selector: 1, values: styleProp });
                    break;
                default:
                    selector;
            }
        }
    }
    rawFrames = rawFrames.sort((a, b) => a.selector - b.selector);
    for (let i = 0; i < rawFrames.length; i++) {
        const frame = rawFrames[i];
        const animationProgress = frame.selector;
        const previousProgress = i === 0 ? 0 : rawFrames[i - 1].selector;
        const progress = animationProgress - previousProgress;
        for (const [key, value] of Object.entries(frame.values)) {
            if (progress === 0) {
                frames[key] = [];
            }
            else {
                frames[key] ??= [{ value: "!INHERIT!", progress: 0 }];
            }
            frames[key].push({
                value,
                progress,
            });
        }
    }
    extractOptions.keyframes.set(keyframes.name.value, extractedAnimation);
}
function getExtractedStyles(declarationBlock, options, mapping = {}) {
    const extractedStyles = [];
    if (declarationBlock.declarations && declarationBlock.declarations.length) {
        extractedStyles.push(declarationsToStyle(declarationBlock.declarations, options, {
            I: 0,
            S: 1,
            O: options.appearanceOrder,
        }, mapping));
    }
    if (declarationBlock.importantDeclarations &&
        declarationBlock.importantDeclarations.length) {
        extractedStyles.push(declarationsToStyle(declarationBlock.importantDeclarations, options, {
            I: 1,
            S: 1,
            O: options.appearanceOrder,
        }, mapping));
    }
    return extractedStyles;
}
function declarationsToStyle(declarations, options, specificity, mapping) {
    const extractedStyle = {
        specificity: { A: 0, B: 0, C: 0, ...specificity },
        props: {},
        propSingleValue: {},
        scope: shared_1.STYLE_SCOPES.GLOBAL,
    };
    function addStyleProp(attribute, value) {
        let prop = "style";
        if (value === undefined && options.useInitialIfUndefined) {
            value = "!INITIAL!";
        }
        if (value === undefined) {
            return;
        }
        if (attribute.startsWith("--")) {
            return addVariable(attribute, value);
        }
        if (typeof value === "string" || typeof value === "number") {
            extractedStyle.scope = Math.max(shared_1.STYLE_SCOPES.GLOBAL, extractedStyle.scope);
        }
        else {
            extractedStyle.scope = Math.max(shared_1.STYLE_SCOPES.SELF, extractedStyle.scope);
        }
        const mappingValue = mapping[attribute] ?? mapping["*"];
        if (mappingValue) {
            if ("hoist" in mappingValue) {
                prop = mappingValue.hoist;
                extractedStyle.props[prop] = {
                    $$type: "prop",
                    value,
                };
            }
            else if ("prop" in mappingValue) {
                prop = mappingValue.prop;
                attribute = mappingValue.attribute ?? attribute;
                attribute = toRNProperty(attribute);
                extractedStyle.props[prop] ??= {};
                extractedStyle.props[prop][attribute] = value;
            }
        }
        else {
            let hoisted = getHoisted(attribute);
            attribute = toRNProperty(attribute);
            extractedStyle.props.style ??= {};
            extractedStyle.props.style[attribute] = value;
            if (hoisted) {
                extractedStyle.hoistedStyles ??= [];
                extractedStyle.hoistedStyles?.push(["style", attribute, hoisted]);
            }
        }
    }
    function handleStyleShorthand(name, options) {
        if (allEqual(...Object.values(options))) {
            return addStyleProp(name, Object.values(options)[0]);
        }
        else {
            for (const [name, value] of Object.entries(options)) {
                addStyleProp(name, value);
            }
        }
    }
    function addVariable(property, value) {
        extractedStyle.variables ??= [];
        extractedStyle.variables.push([property, value]);
    }
    function addContainerProp(declaration) {
        let names = [shared_1.DEFAULT_CONTAINER_NAME];
        let type;
        switch (declaration.property) {
            case "container":
                if (declaration.value.name.type === "none") {
                    names = false;
                }
                else {
                    names = declaration.value.name.value;
                }
                type = declaration.value.containerType;
                break;
            case "container-name":
                if (declaration.value.type === "none") {
                    names = false;
                }
                else {
                    names = declaration.value.value;
                }
                break;
            case "container-type":
                type = declaration.value;
                break;
        }
        extractedStyle.container ??= {};
        if (names === false) {
            extractedStyle.container.names = false;
        }
        else if (Array.isArray(extractedStyle.container.names)) {
            extractedStyle.container.names = [
                ...new Set([...extractedStyle.container.names, ...names]),
            ];
        }
        else {
            extractedStyle.container.names = names;
        }
        if (type) {
            extractedStyle.container ??= {};
            extractedStyle.container.type = type;
        }
    }
    function addTransitionProp(declaration) {
        extractedStyle.transition ??= {};
        switch (declaration.property) {
            case "transition-property":
                extractedStyle.transition.property = [];
                for (const v of declaration.value) {
                    let hoisted = getHoisted(v.property);
                    if (hoisted) {
                        extractedStyle.hoistedStyles ??= [];
                        extractedStyle.hoistedStyles?.push([
                            "style",
                            v.property,
                            "transform",
                        ]);
                    }
                    extractedStyle.transition.property.push(toRNProperty(v.property));
                }
                break;
            case "transition-duration":
                extractedStyle.transition.duration = declaration.value;
                break;
            case "transition-delay":
                extractedStyle.transition.delay = declaration.value;
                break;
            case "transition-timing-function":
                extractedStyle.transition.timingFunction = declaration.value;
                break;
            case "transition": {
                let setProperty = true;
                let setDuration = true;
                let setDelay = true;
                let setTiming = true;
                if (extractedStyle.transition.property) {
                    setProperty = false;
                }
                else {
                    extractedStyle.transition.property = [];
                }
                if (extractedStyle.transition.duration) {
                    setDuration = false;
                }
                else {
                    extractedStyle.transition.duration = [];
                }
                if (extractedStyle.transition.delay) {
                    setDelay = false;
                }
                else {
                    extractedStyle.transition.delay = [];
                }
                if (extractedStyle.transition.timingFunction) {
                    setTiming = false;
                }
                else {
                    extractedStyle.transition.timingFunction = [];
                }
                for (const value of declaration.value) {
                    if (setProperty) {
                        extractedStyle.transition.property?.push(toRNProperty(value.property.property));
                    }
                    if (setDuration) {
                        extractedStyle.transition.duration?.push(value.duration);
                    }
                    if (setDelay) {
                        extractedStyle.transition.delay?.push(value.delay);
                    }
                    if (setTiming) {
                        extractedStyle.transition.timingFunction?.push(value.timingFunction);
                    }
                }
                break;
            }
        }
    }
    function addAnimationProp(property, value) {
        if (property === "animation") {
            const groupedProperties = {};
            for (const animation of value) {
                for (const [key, value] of Object.entries(animation)) {
                    groupedProperties[key] ??= [];
                    groupedProperties[key].push(value);
                }
            }
            extractedStyle.animations ??= {};
            for (const [property, value] of Object.entries(groupedProperties)) {
                const key = property
                    .replace("animation-", "")
                    .replace(/-./g, (x) => x[1].toUpperCase());
                extractedStyle.animations[key] ??= value;
            }
        }
        else {
            const key = property
                .replace("animation-", "")
                .replace(/-./g, (x) => x[1].toUpperCase());
            extractedStyle.animations ??= {};
            extractedStyle.animations[key] = value;
        }
    }
    function addWarning(warning) {
        const warningRegexArray = options.ignorePropertyWarningRegex;
        if (warningRegexArray) {
            const match = warningRegexArray.some((regex) => new RegExp(regex).test(warning.property));
            if (match)
                return;
        }
        extractedStyle.warnings ??= [];
        extractedStyle.warnings.push(warning);
    }
    function requiresLayout(name) {
        if (name === "rnw") {
            extractedStyle.requiresLayoutWidth = true;
        }
        else {
            extractedStyle.requiresLayoutHeight = true;
        }
    }
    const parseDeclarationOptions = {
        addStyleProp,
        handleStyleShorthand,
        addAnimationProp,
        addContainerProp,
        addTransitionProp,
        requiresLayout,
        addWarning,
        ...options,
    };
    for (const declaration of declarations) {
        (0, parseDeclaration_1.parseDeclaration)(declaration, parseDeclarationOptions);
    }
    return extractedStyle;
}
function allEqual(...params) {
    return params.every((param, index, array) => {
        return index === 0 ? true : equal(array[0], param);
    });
}
function equal(a, b) {
    if (a === b)
        return true;
    if (typeof a !== typeof b)
        return false;
    if (a === null || b === null)
        return false;
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            if (!equal(a[i], b[i]))
                return false;
        }
        return true;
    }
    if (typeof a === "object" && typeof b === "object") {
        if (Object.keys(a).length !== Object.keys(b).length)
            return false;
        for (const key in a) {
            if (!equal(a[key], b[key]))
                return false;
        }
        return true;
    }
    return false;
}
function toRNProperty(str) {
    if (str.startsWith("-rn-")) {
        str = str.slice("-rn-".length);
    }
    return str.replace(/-./g, (x) => x[1].toUpperCase());
}
function getHoisted(property) {
    if (transformProperties.has(property)) {
        return "transform";
    }
    if (shadowProperties.has(property)) {
        return "shadow";
    }
}
const transformProperties = new Set([
    "perspective",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "scaleZ",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skewX",
    "skewY",
    "skewZ",
    "matrix",
    "matrix3d",
]);
const shadowProperties = new Set([
    "-rn-shadow-offset.width",
    "-rn-shadow-offset.height",
    "-rn-text-shadow-offset.width",
    "-rn-text-shadow-offset.height",
    "shadow-offset.width",
    "shadow-offset.height",
    "text-shadow-offset.width",
    "text-shadow-offset.height",
]);
//# sourceMappingURL=index.js.map