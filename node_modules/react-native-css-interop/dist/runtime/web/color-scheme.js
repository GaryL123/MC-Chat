"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useColorScheme = exports.colorScheme = void 0;
const react_native_1 = require("react-native");
const stylesheet_1 = require("./stylesheet");
const signals_1 = require("../signals");
const shared_1 = require("../../shared");
let appearance = react_native_1.Appearance;
let appearanceListener = appearance.addChangeListener((state) => _colorScheme.set(state.colorScheme ?? "light"));
react_native_1.AppState.addEventListener("change", () => _colorScheme.set(appearance.getColorScheme() ?? "light"));
const [darkMode, darkModeValue] = stylesheet_1.StyleSheet.getFlag("darkMode")?.split(" ") ?? ["media"];
let initialColor = "system";
if (darkMode === "media") {
    initialColor = react_native_1.Appearance.getColorScheme() ?? "light";
    react_native_1.Appearance.addChangeListener(({ colorScheme }) => {
        if (darkMode === "media") {
            _colorScheme.set(colorScheme ?? "light");
        }
    });
}
else if (darkMode === "class") {
    initialColor = globalThis.window.document.documentElement.classList.contains(darkModeValue)
        ? "dark"
        : "light";
}
const _colorScheme = (0, signals_1.createSignal)(initialColor);
exports.colorScheme = {
    ..._colorScheme,
    set(value) {
        _colorScheme.set(value);
        if (darkMode === "media") {
            throw new Error("Cannot manually set color scheme, as dark mode is type 'media'. Please use StyleSheet.setFlag('darkMode', 'class')");
        }
        if (!globalThis.window) {
            throw new Error("Cannot manually set color scheme while not in a browser environment.");
        }
        if (value === "dark") {
            globalThis.window?.document.documentElement.classList.add(darkModeValue);
        }
        else {
            globalThis.window?.document.documentElement.classList.remove(darkModeValue);
        }
    },
    get() {
        let current = _colorScheme.get();
        if (current === "system")
            current = appearance.getColorScheme() ?? "light";
        return current;
    },
    toggle() {
        let current = _colorScheme.peek();
        if (current === "system")
            current = appearance.getColorScheme() ?? "light";
        exports.colorScheme.set(current === "light" ? "dark" : "light");
    },
    [shared_1.INTERNAL_RESET]: ($appearance) => {
        _colorScheme.set("system");
        appearance = $appearance;
        appearanceListener.remove();
        appearanceListener = appearance.addChangeListener((state) => _colorScheme.set(state.colorScheme ?? "light"));
    },
};
function useColorScheme() {
    return (0, signals_1.useComputed)(() => {
        return {
            colorScheme: exports.colorScheme.get(),
            setColorScheme: exports.colorScheme.set,
            toggleColorScheme: exports.colorScheme.toggle,
        };
    });
}
exports.useColorScheme = useColorScheme;
//# sourceMappingURL=color-scheme.js.map