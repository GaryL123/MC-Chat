import type { InteropStore } from "../types";
export declare const interopGlobal: {
    isInComponent: boolean;
    current: Effect | null;
    delayedEvents: Set<() => void>;
};
export declare const context: Effect[];
export type Signal<T> = ReturnType<typeof createSignal<T>>;
type SignalSetFn<T> = (previous?: T) => T;
export type Effect = {
    (): void;
    dependencies: Set<Signal<any>>;
    state?: InteropStore;
};
export declare function createSignal<T = unknown>(value: T, id?: string): {
    subscriptions: Set<Computed<any> | (() => void)>;
    get(): T;
    id: string | undefined;
    peek(): T;
    set(nextValue: T | undefined | SignalSetFn<T>): void;
    subscribe(callback: () => void): () => void;
    unsubscribe(callback: () => void): void;
};
export interface Computed<T = unknown> extends Signal<T> {
    (): void;
    dependencies: Set<Signal<any>>;
    fn: SignalSetFn<T>;
    runInEffect<T>(fn: () => T): T;
}
export declare function setupEffect(effect: Effect): void;
export declare function cleanupEffect(effect: Effect): void;
export declare function createComputed<T>(fn: SignalSetFn<T>, runOnInitialization?: boolean, id?: string): Computed<T>;
export declare function useComputed<T>(fn: () => T, dependency?: any): T;
export {};
