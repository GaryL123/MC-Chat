"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createElementAndCheckCssInterop = exports.remapProps = exports.cssInterop = exports.render = exports.interopComponents = void 0;
const react_1 = require("react");
const interop_1 = require("../native/interop");
const signals_1 = require("../signals");
const globals_1 = require("../native/globals");
exports.interopComponents = new Map();
function render(jsx, type, props, ...args) {
    const interop = exports.interopComponents.get(type);
    if (interop?.check(props)) {
        if (props.ref) {
            props.___ref = props.ref;
            delete props.ref;
        }
        return jsx(interop.type, props, ...args);
    }
    else {
        return jsx(type, props, ...args);
    }
}
exports.render = render;
const cssInterop = (component, mapping) => {
    const config = getNormalizeConfig(mapping);
    const CssInteropComponent = (0, react_1.forwardRef)(function CssInteropComponent({ children, ___pressable, ___ref, ...props }, ref) {
        if (___ref || ref) {
            props.ref = ___ref || ref;
        }
        if (___pressable) {
            return (0, react_1.createElement)(component, props, children);
        }
        else {
            signals_1.interopGlobal.isInComponent = true;
            signals_1.interopGlobal.current = null;
            const element = (0, interop_1.defaultCSSInterop)(component, config, props, children);
            const originalType = element.props;
            return Object.create(element, {
                props: {
                    get() {
                        signals_1.interopGlobal.isInComponent = false;
                        signals_1.interopGlobal.current = null;
                        if (signals_1.interopGlobal.delayedEvents.size) {
                            for (const sub of signals_1.interopGlobal.delayedEvents) {
                                sub();
                            }
                            signals_1.interopGlobal.delayedEvents.clear();
                        }
                        return originalType;
                    },
                },
            });
        }
    });
    if (process.env.NODE_ENV === "development") {
        if (typeof component === "string") {
            CssInteropComponent.displayName = `CSSInterop.${component}`;
        }
        else {
            CssInteropComponent.displayName = `CSSInterop.${component.displayName ?? component.name ?? "unknown"}`;
        }
    }
    const checkArray = (props) => props.some((prop) => {
        return Array.isArray(prop) ? checkArray(prop) : globals_1.opaqueStyles.has(prop);
    });
    const interopComponent = {
        type: CssInteropComponent,
        createElement(props, ...children) {
            if (props.children) {
                children = props.children;
            }
            return (0, interop_1.defaultCSSInterop)(component, config, props, children);
        },
        check(props) {
            for (const [targetProp, source, nativeStyleToProp] of config.config) {
                if (nativeStyleToProp)
                    return true;
                if (typeof props[source] === "string") {
                    return true;
                }
                const target = props[targetProp];
                if (Array.isArray(target)) {
                    if (checkArray(target)) {
                        return true;
                    }
                }
                else if (globals_1.opaqueStyles.has(target)) {
                    return true;
                }
            }
            return false;
        },
    };
    exports.interopComponents.set(component, interopComponent);
    return component;
};
exports.cssInterop = cssInterop;
const remapProps = (component, mapping) => {
    const { config } = getNormalizeConfig(mapping);
    let render = ({ ...props }) => {
        for (const entry of config) {
            const key = entry[0];
            const sourceProp = entry[1];
            let rawStyles = [];
            const source = props?.[sourceProp];
            if (typeof source !== "string")
                continue;
            delete props[sourceProp];
            for (const className of source.split(/\s+/)) {
                const signal = globals_1.styleSignals.get(className);
                if (signal !== undefined) {
                    const style = {};
                    globals_1.opaqueStyles.set(style, signal.get());
                    rawStyles.push(style);
                }
            }
            if (rawStyles.length !== 0) {
                const existingStyle = props[key];
                if (Array.isArray(existingStyle)) {
                    rawStyles.push(...existingStyle);
                }
                else if (existingStyle) {
                    rawStyles.push(existingStyle);
                }
                props[key] = rawStyles.length === 1 ? rawStyles[0] : rawStyles;
            }
        }
        if (props.___ref) {
            props.ref = props.___ref;
            delete props.___ref;
        }
        return (0, react_1.createElement)(component, props, props.children);
    };
    const interopComponent = {
        type: render,
        check: () => true,
        createElement(props, ...children) {
            return (0, react_1.createElement)(interopComponent.type, props, ...children);
        },
    };
    exports.interopComponents.set(component, interopComponent);
    return component;
};
exports.remapProps = remapProps;
function createElementAndCheckCssInterop(type, props, ...children) {
    if (!type)
        return (0, react_1.createElement)(type, props, ...children);
    const interop = exports.interopComponents.get(type);
    return !interop || !interop.check(props)
        ? (0, react_1.createElement)(type, props, ...children)
        : interop.createElement(props, children);
}
exports.createElementAndCheckCssInterop = createElementAndCheckCssInterop;
function getNormalizeConfig(mapping) {
    const config = new Map();
    const dependencies = new Set();
    const sources = new Set();
    for (const [key, options] of Object.entries(mapping)) {
        let target;
        let nativeStyleToProp;
        if (!options)
            continue;
        if (typeof options === "boolean") {
            target = key;
        }
        else if (typeof options === "string") {
            target = options;
        }
        else if (typeof options.target === "boolean") {
            target = key;
            nativeStyleToProp = options.nativeStyleToProp;
        }
        else if (typeof options.target === "string") {
            target = options.target;
            nativeStyleToProp = options.nativeStyleToProp;
        }
        else {
            throw new Error(`Unknown cssInterop target from config: ${JSON.stringify(config)}`);
        }
        config.set(target, [key, nativeStyleToProp]);
        dependencies.add(target);
        dependencies.add(key);
        sources.add(key);
    }
    return {
        dependencies: Array.from(dependencies),
        sources: Array.from(sources),
        config: Array.from(config.entries()).map(([key, [source, nativeStyleToProp]]) => [key, source, nativeStyleToProp]),
    };
}
try {
    const { Svg } = require("react-native-svg");
    (0, exports.cssInterop)(Svg, { className: "style" });
}
catch { }
try {
    const { SafeAreaView } = require("react-native-safe-area-context");
    (0, exports.cssInterop)(SafeAreaView, { className: "style" });
}
catch { }
//# sourceMappingURL=rendering.native.js.map