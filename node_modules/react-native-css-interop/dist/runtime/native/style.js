"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultValues = exports.timeToMS = exports.specificityCompare = exports.resolveAnimationValue = exports.parseValue = exports.reduceStyles = exports.upsertStyleSignal = exports.createInteropStore = void 0;
const react_native_1 = require("react-native");
const react_native_reanimated_1 = require("react-native-reanimated");
const signals_1 = require("../signals");
const globals_1 = require("./globals");
const shared_1 = require("../../shared");
const conditions_1 = require("./conditions");
function createInteropStore(parent, options, originalProps) {
    const state = {
        testId: originalProps.testId,
        version: 0,
        parent,
        options,
        props: {},
        originalProps,
        scope: shared_1.STYLE_SCOPES.GLOBAL,
        interaction: {},
        hasActive: false,
        hasHover: false,
        hasFocus: false,
        hasContainer: false,
        shouldUpdateContext: false,
        convertToPressable: false,
        animationWaitingOnLayout: false,
        requiresLayoutHeight: false,
        requiresLayoutWidth: false,
        isAnimated: false,
        animationNames: new Set(),
        inlineVariablesToRemove: new Set(),
        inlineVariables: new Map(),
        containerNames: new Set(),
        sharedValues: {},
        dependencies: options.dependencies.map((k) => originalProps[k]),
        attrDependencies: [],
        setVariable(name, value) {
            state.inlineVariablesToRemove.delete(name);
            const existing = state.inlineVariables.get(name);
            if (!existing) {
                state.inlineVariables.set(name, (0, signals_1.createSignal)(value, name));
            }
            else {
                existing.set(value);
            }
        },
        getVariable(name) {
            let value = undefined;
            value ??= state.inlineVariables.get(name)?.get();
            value ??= globals_1.globalVariables.universal.get(name)?.get();
            value ??= parent.getVariable(name);
            return value;
        },
        setContainer(name) {
            state.containerSignal ??= (0, signals_1.createSignal)(state, name);
            state.containerNames.add(name);
        },
        getContainer(name) {
            if (state.containerSignal &&
                (state.containerNames.has(name) || name === shared_1.DEFAULT_CONTAINER_NAME)) {
                return state.containerSignal.get();
            }
            else {
                return parent.getContainer(name);
            }
        },
        getInteraction(name) {
            if (!this.interaction[name]) {
                this.interaction[name] = (0, signals_1.createSignal)(false, name);
            }
            return this.interaction[name].get();
        },
        effect: Object.assign(() => {
            state.rerender();
            state.onChange?.();
        }, {
            dependencies: new Set(),
        }),
        rerender: (parent, originalProps) => {
            render(state, parent, originalProps);
        },
    };
    state.effect.state = state;
    render(state);
    return {
        state,
        subscribe(subscriber) {
            state.onChange = subscriber;
            return () => {
                state.onChange = undefined;
                (0, signals_1.cleanupEffect)(state.effect);
            };
        },
        snapshot() {
            return state.version;
        },
    };
}
exports.createInteropStore = createInteropStore;
function render(state, parent, originalProps) {
    if (parent)
        state.parent = parent;
    if (originalProps) {
        state.originalProps = originalProps;
        state.dependencies = state.options.dependencies.map((k) => state.originalProps[k]);
    }
    state.shouldUpdateContext = false;
    state.convertToPressable ||= false;
    state.inlineVariablesToRemove = new Set(state.inlineVariables.keys());
    state.props = {};
    state.attrDependencies = [];
    (0, signals_1.setupEffect)(state.effect);
    signals_1.interopGlobal.delayedEvents.delete(state.effect);
    let maxScope = shared_1.STYLE_SCOPES.GLOBAL;
    const mapping = [];
    for (const [prop, sourceProp, nativeStyleToProp] of state.options.config) {
        const classNames = state.originalProps?.[sourceProp];
        const layers = {
            classNames,
            0: [],
            1: [],
            2: [],
        };
        if (classNames) {
            globals_1.externalClassNameCompilerCallback.current?.(classNames);
            for (const className of classNames.split(/\s+/)) {
                let signal = globals_1.styleSignals.get(className);
                if (!signal)
                    continue;
                const meta = signal.get();
                maxScope = Math.max(maxScope, meta.scope);
                if (meta[0])
                    layers[0].push(...meta[0]);
                if (meta[1])
                    layers[1].push(...meta[1]);
                if (meta[2])
                    layers[2].push(...meta[2]);
            }
        }
        let inlineStyles = state.originalProps?.[prop];
        if (inlineStyles) {
            if (Array.isArray(inlineStyles)) {
                for (let style of inlineStyles.flat(10)) {
                    if (globals_1.opaqueStyles.has(style)) {
                        const opaqueStyle = globals_1.opaqueStyles.get(style);
                        maxScope = Math.max(maxScope, opaqueStyle.scope);
                        if (opaqueStyle[0]) {
                            layers[1].push(...opaqueStyle[0]);
                        }
                        if (opaqueStyle[1]) {
                            layers[1].push(...opaqueStyle[1]);
                        }
                        if (opaqueStyle[2]) {
                            layers[2].push(...opaqueStyle[2]);
                        }
                    }
                    else {
                        layers[1].push(style);
                    }
                }
            }
            else {
                if (globals_1.opaqueStyles.has(inlineStyles)) {
                    const opaqueStyle = globals_1.opaqueStyles.get(inlineStyles);
                    maxScope = Math.max(maxScope, opaqueStyle.scope);
                    if (opaqueStyle[0]) {
                        layers[1].push(...opaqueStyle[0]);
                    }
                    if (opaqueStyle[1]) {
                        layers[1].push(...opaqueStyle[1]);
                    }
                    if (opaqueStyle[2]) {
                        layers[2].push(...opaqueStyle[2]);
                    }
                }
                else {
                    layers[1].push(inlineStyles);
                }
            }
        }
        mapping.push([prop, layers, nativeStyleToProp]);
    }
    for (const [prop, layers, nativeStyleToProp] of mapping) {
        if (layers[0].length) {
            reduceStyles(state, prop, layers[0], maxScope);
        }
        if (layers[1].length) {
            reduceStyles(state, prop, layers[1], maxScope, true);
        }
        if (layers[2].length) {
            reduceStyles(state, prop, layers[2], maxScope, true);
        }
        if (state.props[prop]) {
            resolveObject(state.props[prop]);
        }
        if (prop === "style") {
            const styleProp = state.props[prop];
            if (styleProp && typeof styleProp.width === "number") {
                state.requiresLayoutWidth = false;
            }
            if (styleProp && typeof styleProp.height === "number") {
                state.requiresLayoutHeight = false;
            }
            const seenAnimatedProps = new Set();
            if (state.animations) {
                const { name: animationNames, duration: durations, delay: delays, iterationCount: iterationCounts, timingFunction: timingFunctions, } = state.animations;
                state.isAnimated = true;
                state.props.style ??= {};
                let names = [];
                let shouldResetAnimations = state.animationWaitingOnLayout;
                for (const name of animationNames) {
                    if (name.type === "none") {
                        names = [];
                        state.animationNames.clear();
                        break;
                    }
                    names.push(name.value);
                    if (!state.animationNames.has(name.value)) {
                        shouldResetAnimations = true;
                    }
                }
                if (shouldResetAnimations) {
                    state.animationNames.clear();
                    state.animationWaitingOnLayout = false;
                    for (let index = names.length - 1; index >= 0; index--) {
                        const name = names[index % names.length];
                        state.animationNames.add(name);
                        const keyframes = globals_1.animationMap.get(name);
                        if (!keyframes) {
                            continue;
                        }
                        const totalDuration = (0, exports.timeToMS)(durations[index % name.length]);
                        const delay = (0, exports.timeToMS)(delays[index % delays.length]);
                        const timingFunction = timingFunctions[index % timingFunctions.length];
                        const iterationCount = iterationCounts[index % iterationCounts.length];
                        const iterations = iterationCount.type === "infinite" ? -1 : iterationCount.value;
                        if (keyframes.hoistedStyles) {
                            state.hoistedStyles ??= [];
                            state.hoistedStyles.push(...keyframes.hoistedStyles);
                        }
                        for (const [key, [initialFrame, ...frames]] of Object.entries(keyframes.frames)) {
                            if (seenAnimatedProps.has(key))
                                continue;
                            seenAnimatedProps.add(key);
                            const initialValue = resolveAnimationValue(initialFrame.value, key, state.props.style);
                            const sequence = frames.map((frame) => {
                                return (0, react_native_reanimated_1.withDelay)(delay, (0, react_native_reanimated_1.withTiming)(resolveAnimationValue(frame.value, key, state.props.style), {
                                    duration: totalDuration * frame.progress,
                                    easing: getEasing(timingFunction),
                                }));
                            });
                            state.animationWaitingOnLayout =
                                (state.requiresLayoutWidth || state.requiresLayoutHeight) &&
                                    !state.layout?.peek();
                            let sharedValue = state.sharedValues[key];
                            if (!sharedValue) {
                                sharedValue = (0, react_native_reanimated_1.makeMutable)(initialValue);
                                state.sharedValues[key] = sharedValue;
                            }
                            else {
                                sharedValue.value = initialValue;
                            }
                            sharedValue.value = (0, react_native_reanimated_1.withRepeat)((0, react_native_reanimated_1.withSequence)(...sequence), iterations);
                            state.props[prop][key] = sharedValue;
                        }
                    }
                }
                else {
                    for (const name of names) {
                        const keyframes = globals_1.animationMap.get(name);
                        if (!keyframes) {
                            continue;
                        }
                        state.props[prop] ??= {};
                        if (keyframes.hoistedStyles) {
                            state.hoistedStyles ??= [];
                            state.hoistedStyles.push(...keyframes.hoistedStyles);
                        }
                        for (const key of Object.keys(keyframes.frames)) {
                            Object.defineProperty(state.props[prop], key, {
                                configurable: true,
                                enumerable: true,
                                value: state.sharedValues[key],
                            });
                            seenAnimatedProps.add(key);
                        }
                    }
                }
            }
            if (state.transition) {
                state.isAnimated = true;
                const { property: properties, duration: durations, delay: delays, timingFunction: timingFunctions, } = state.transition;
                for (let index = 0; index < properties.length; index++) {
                    const key = properties[index];
                    if (seenAnimatedProps.has(key))
                        continue;
                    let value = state.props[prop][key] ?? exports.defaultValues[key];
                    if (typeof value === "function") {
                        value = value();
                    }
                    if (value === undefined)
                        continue;
                    seenAnimatedProps.add(key);
                    const duration = (0, exports.timeToMS)(durations[index % durations.length]);
                    const delay = (0, exports.timeToMS)(delays[index % delays.length]);
                    const easing = timingFunctions[index % timingFunctions.length];
                    let sharedValue = state.sharedValues[key];
                    if (!sharedValue) {
                        sharedValue = (0, react_native_reanimated_1.makeMutable)(value);
                        state.sharedValues[key] = sharedValue;
                    }
                    if (value !== sharedValue.value) {
                        sharedValue.value = (0, react_native_reanimated_1.withDelay)(delay, (0, react_native_reanimated_1.withTiming)(value, {
                            duration,
                            easing: getEasing(easing),
                        }));
                    }
                    Object.defineProperty(state.props[prop], key, {
                        configurable: true,
                        enumerable: true,
                        value: sharedValue,
                    });
                }
            }
            for (const [key, value] of Object.entries(state.sharedValues)) {
                if (seenAnimatedProps.has(key))
                    continue;
                (0, react_native_reanimated_1.cancelAnimation)(value);
                value.value = state.props[prop][key] ?? exports.defaultValues[key];
            }
        }
        if (state.hoistedStyles) {
            for (let hoisted of state.hoistedStyles) {
                const prop = hoisted[0];
                const key = hoisted[1];
                if (state.props[prop] && key in state.props[prop]) {
                    switch (hoisted[2]) {
                        case "transform":
                            state.props[prop].transform ??= [];
                            state.props[prop].transform.push({
                                [key]: state.props[prop][key],
                            });
                            delete state.props[prop][key];
                            break;
                        case "shadow":
                            const [type, shadowKey] = key.split(".");
                            state.props[prop][type] ??= {};
                            state.props[prop][type][shadowKey] = state.props[prop][key];
                            delete state.props[prop][key];
                            break;
                    }
                }
            }
        }
        if (nativeStyleToProp) {
            for (let [key, targetProp] of Object.entries(nativeStyleToProp)) {
                if (targetProp === true)
                    targetProp = key;
                if (state.props?.style?.[key] === undefined)
                    continue;
                state.props[targetProp] = state.props.style[key];
                delete state.props.style[key];
            }
        }
    }
    if (state.hasActive || state.hasContainer) {
        state.convertToPressable = true;
        state.interaction.active ??= (0, signals_1.createSignal)(false, `${state.testId}#active`);
        state.props.onPressIn = (event) => {
            state.originalProps.onPressIn?.(event);
            state.interaction.active.set(true);
        };
        state.props.onPressOut = (event) => {
            state.originalProps.onPressOut?.(event);
            state.interaction.active.set(false);
        };
    }
    if (state.hasHover || state.hasContainer) {
        state.convertToPressable = true;
        state.interaction.hover ??= (0, signals_1.createSignal)(false, `${state.testId}#hover`);
        state.props.onHoverIn = (event) => {
            state.originalProps.onHoverIn?.(event);
            state.interaction.hover.set(true);
        };
        state.props.onHoverOut = (event) => {
            state.originalProps.onHoverOut?.(event);
            state.interaction.hover.set(false);
        };
    }
    if (state.hasFocus || state.hasContainer) {
        state.convertToPressable = true;
        state.interaction.hover ??= (0, signals_1.createSignal)(false, `${state.testId}#focus`);
        state.props.onFocus = (event) => {
            state.originalProps.onFocus?.(event);
            state.interaction.focus.set(true);
        };
        state.props.onBlur = (event) => {
            state.originalProps.onBlur?.(event);
            state.interaction.focus.set(false);
        };
    }
    if (state.convertToPressable) {
        state.props.onPress = state.originalProps.onPress ?? (() => { });
    }
    if (state.requiresLayoutWidth ||
        state.requiresLayoutHeight ||
        state.animationWaitingOnLayout) {
        if (!state.layout) {
            state.layout ??= (0, signals_1.createSignal)(undefined);
            state.layout.get();
        }
        else if (!state.layout.peek()) {
            state.layout.get();
        }
        state.props.onLayout ??= (event) => {
            state.originalProps.onLayout?.(event);
            const layout = event.nativeEvent.layout;
            const [width, height] = state.layout.peek() ?? [0, 0];
            if (layout.width !== width || layout.height !== height) {
                state.layout.set([layout.width, layout.height]);
            }
        };
    }
    if (state.containerNames.size === 0) {
        state.containerSignal?.set(undefined);
        state.containerSignal = undefined;
    }
    for (const name of state.inlineVariablesToRemove) {
        state.inlineVariables.get(name)?.set(undefined);
        state.inlineVariables.delete(name);
        state.shouldUpdateContext = true;
    }
    if (state.shouldUpdateContext) {
        state.context = Object.assign({}, state);
    }
    state.version++;
    return state;
}
function upsertStyleSignal(name, groupedStyleMeta) {
    const meta = {
        scope: groupedStyleMeta.scope,
        [0]: groupedStyleMeta[0]?.map(mapStyle),
        [1]: groupedStyleMeta[1]?.map(mapStyle),
        [2]: groupedStyleMeta[2]?.map(mapStyle),
    };
    let signal = globals_1.styleSignals.get(name);
    if (signal) {
        if (!deepEqual(signal.peek(), meta)) {
            signal.set(meta);
            if (process.env.NODE_ENV !== "production") {
                globals_1.warned.delete(name);
                const originalGet = signal.get;
                signal.get = () => {
                    printWarnings(name, groupedStyleMeta);
                    return originalGet();
                };
            }
        }
    }
    else {
        let signal = globals_1.styleSignals.get(name);
        if (signal) {
            signal.set(meta);
        }
        else {
            signal = (0, signals_1.createSignal)(meta, name);
            if (process.env.NODE_ENV !== "production") {
                const originalGet = signal.get;
                signal.get = () => {
                    printWarnings(name, groupedStyleMeta);
                    return originalGet();
                };
            }
            globals_1.styleSignals.set(name, signal);
        }
    }
}
exports.upsertStyleSignal = upsertStyleSignal;
function printWarnings(name, groupedStyleMeta) {
    if (!groupedStyleMeta.warnings)
        return;
    for (const warning of groupedStyleMeta.warnings) {
        if (process.env.NODE_ENV === "test") {
            globals_1.warnings.set(name, groupedStyleMeta.warnings);
        }
        else {
            globals_1.warned.add(name);
            switch (warning.type) {
                case "IncompatibleNativeProperty":
                    console.log("IncompatibleNativeProperty ", warning.property);
                    break;
                case "IncompatibleNativeValue":
                    console.log("IncompatibleNativeValue ", warning.property, warning.value);
                    break;
                case "IncompatibleNativeFunctionValue":
                    console.log("IncompatibleNativeFunctionValue ", warning.property, warning.value);
                    break;
            }
        }
    }
}
function mapStyle(style) {
    return {
        ...style,
        $$type: "runtime",
        props: style.props?.map(([key, value]) => {
            if ((0, shared_1.isPropDescriptor)(value)) {
                return [key, parseValue(value.value)];
            }
            else {
                return [
                    key,
                    Object.fromEntries(value.map(([k, v]) => [k, parseValue(v)])),
                ];
            }
        }),
    };
}
function reduceStyles(state, targetProp, styles, _scope, treatAsInline = false) {
    styles.sort((a, b) => specificityCompare(a, b, treatAsInline));
    for (let style of styles) {
        if (!style)
            continue;
        if (typeof style === "object" && !("$$type" in style)) {
            state.props[targetProp] ??= {};
            Object.assign(state.props[targetProp], style);
            continue;
        }
        if (style.variables || style.container?.names) {
            state.context ??= state;
        }
        if (style.pseudoClasses) {
            state.hasActive ||= Boolean(style.pseudoClasses.active);
            state.hasHover ||= Boolean(style.pseudoClasses.hover);
            state.hasFocus ||= Boolean(style.pseudoClasses.focus);
            if (!(0, conditions_1.testPseudoClasses)(state, style.pseudoClasses)) {
                continue;
            }
        }
        if (style.media && !(0, conditions_1.testMediaQueries)(style.media)) {
            continue;
        }
        if (style.containerQuery &&
            !(0, conditions_1.testContainerQuery)(state, style.containerQuery)) {
            continue;
        }
        if (style.attrs) {
            let passed = true;
            for (const attrCondition of style.attrs) {
                const attrValue = (0, conditions_1.getTestAttributeValue)(state.originalProps, attrCondition);
                state.attrDependencies.push({ ...attrCondition, previous: attrValue });
                if (!(0, conditions_1.testAttribute)(attrValue, attrCondition))
                    passed = false;
            }
            if (!passed)
                continue;
        }
        if (style.hoistedStyles) {
            state.hoistedStyles ??= [];
            state.hoistedStyles.push(...style.hoistedStyles);
        }
        if (style.variables) {
            for (const [key, value] of style.variables) {
                state.setVariable(key, value, style.specificity);
            }
        }
        if (style.animations) {
            state.animations = {
                ...defaultAnimation,
                ...state.animations,
                ...style.animations,
            };
        }
        if (style.transition) {
            state.transition = {
                ...defaultTransition,
                ...state.transition,
                ...style.transition,
            };
        }
        if (style.container?.names) {
            state.requiresLayoutWidth = true;
            state.requiresLayoutHeight = true;
            state.hasContainer = true;
            for (const name of style.container.names) {
                state.setContainer(name);
            }
        }
        if (style.props) {
            for (let [prop, value] of style.props) {
                if (targetProp !== "style" && prop === "style") {
                    prop = targetProp;
                }
                if (typeof value === "object" && "$$type" in value) {
                    state.props[prop] = value.value;
                }
                else if (value !== undefined) {
                    if (typeof value === "object") {
                        state.props[prop] ??= {};
                        Object.assign(state.props[prop], value);
                    }
                    else {
                        state.props[prop] = value;
                    }
                }
            }
        }
    }
    return state;
}
exports.reduceStyles = reduceStyles;
function parseValue(value) {
    if (typeof value === "string" ||
        typeof value === "number" ||
        typeof value === "boolean") {
        return value;
    }
    if (!("name" in value))
        return value;
    switch (value.name) {
        case "var": {
            return function () {
                return getVariable(value.arguments[0]);
            };
        }
        case "vh": {
            return function () {
                return round((globals_1.vh.get() / 100) * value.arguments[0]);
            };
        }
        case "vw": {
            return function () {
                return round((globals_1.vw.get() / 100) * value.arguments[0]);
            };
        }
        case "em": {
            return function () {
                const style = getProp("style");
                if (style && typeof style.fontSize === "number") {
                    return round(Number((style.fontSize || 0) * value.arguments[0]));
                }
            };
        }
        case "rem": {
            return function () {
                return round(globals_1.rem.get() * value.arguments[0]);
            };
        }
        case "rnh": {
            return function () {
                return round(getDimensions("height") * value.arguments[0]);
            };
        }
        case "rnw": {
            return function () {
                return round(getDimensions("width") * value.arguments[0]);
            };
        }
        case "rgb":
        case "rgba": {
            return function () {
                const args = resolve(value.arguments);
                if (args.length === 3) {
                    return `rgb(${args.join(", ")})`;
                }
                else if (args.length === 4) {
                    return `rgba(${args.join(", ")})`;
                }
                else {
                    return;
                }
            };
        }
        case "hsla": {
            return function () {
                const args = resolve(value.arguments);
                if (args.length === 3) {
                    return `hsl(${args.join(" ")})`;
                }
                else if (args.length === 4) {
                    return `hsla(${args.join(" ")})`;
                }
                else {
                    return;
                }
            };
        }
        case "hairlineWidth": {
            return react_native_1.StyleSheet.hairlineWidth;
        }
        case "platformColor": {
            return (0, react_native_1.PlatformColor)(...value.arguments);
        }
        case "platformSelect": {
            return function () {
                return resolve([react_native_1.Platform.select(value.arguments[0])]);
            };
        }
        case "getPixelSizeForLayoutSize": {
            return function () {
                return react_native_1.PixelRatio.getPixelSizeForLayoutSize(Number(resolve(value.arguments[0])));
            };
        }
        case "fontScale": {
            return function () {
                return react_native_1.PixelRatio.getFontScale() * Number(resolve(value.arguments[0]));
            };
        }
        case "pixelScale": {
            return function () {
                return react_native_1.PixelRatio.get() * Number(resolve(value.arguments[0]));
            };
        }
        case "pixelScaleSelect": {
            return function () {
                const specifics = value.arguments[0];
                return resolve(specifics[react_native_1.PixelRatio.get()] ?? specifics["default"]);
            };
        }
        case "fontScaleSelect": {
            return function () {
                const specifics = value.arguments[0];
                return resolve(specifics[react_native_1.PixelRatio.getFontScale()] ?? specifics["default"]);
            };
        }
        case "roundToNearestPixel": {
            return function () {
                return react_native_1.PixelRatio.roundToNearestPixel(Number(resolve(value.arguments[0])));
            };
        }
        default: {
            return function () {
                const args = resolve(value.arguments).join(",");
                return `${value.name}(${args})`;
            };
        }
    }
}
exports.parseValue = parseValue;
function resolve(args) {
    let resolved = [];
    if (args === undefined)
        return;
    if (Array.isArray(args)) {
        for (const arg of args) {
            resolved.push(resolve(arg));
        }
        resolved = resolved.flat(10);
        if (resolved.length === 0) {
            return;
        }
        else if (resolved.length === 1) {
            return resolved[0];
        }
        else {
            return resolved;
        }
    }
    else if (typeof args === "function") {
        return resolve(args());
    }
    else {
        const value = parseValue(args);
        if (value === undefined || Number.isNaN(value))
            return;
        if (typeof value === "function")
            return resolve(value());
        return value;
    }
}
function resolveAnimationValue(value, prop, style = {}) {
    if (value === "!INHERIT!") {
        return style[prop] ?? exports.defaultValues[prop];
    }
    else if (value === "!INITIAL!") {
        return exports.defaultValues[prop];
    }
    else {
        return resolve(value);
    }
}
exports.resolveAnimationValue = resolveAnimationValue;
function round(number) {
    return Math.round((number + Number.EPSILON) * 100) / 100;
}
function specificityCompare(o1, o2, treatAsInline = false) {
    if (!("specificity" in o1) || !("specificity" in o2)) {
        return 0;
    }
    const a = o1.specificity;
    const b = o2.specificity;
    if (a.I !== b.I) {
        return a.I - b.I;
    }
    else if (!treatAsInline && a.inline !== b.inline) {
        return (a.inline || 0) - (b.inline || 0);
    }
    else if (a.A !== b.A) {
        return a.A - b.A;
    }
    else if (a.B !== b.B) {
        return a.B - b.B;
    }
    else if (a.C !== b.C) {
        return a.C - b.C;
    }
    else if (a.S !== b.S) {
        return a.S - b.S;
    }
    else if (a.O !== b.O) {
        return a.O - b.O;
    }
    else {
        return 0;
    }
}
exports.specificityCompare = specificityCompare;
const timeToMS = (time) => {
    return time.type === "milliseconds" ? time.value : time.value * 1000;
};
exports.timeToMS = timeToMS;
function getProp(name) {
    return signals_1.interopGlobal.current?.state?.props[name];
}
function getDimensions(dimension, prop = "style") {
    const state = signals_1.interopGlobal.current?.state;
    const style = state.props[prop];
    if (dimension === "width") {
        if (typeof style?.width === "number") {
            return style.width;
        }
        else {
            state.requiresLayoutWidth = true;
            return state.layout?.get()?.[0] ?? 0;
        }
    }
    else if (dimension === "height") {
        if (typeof style?.height === "number") {
            return style.height;
        }
        else {
            state.requiresLayoutHeight = true;
            return state.layout?.get()?.[1] ?? 0;
        }
    }
    else {
        let width = 0;
        let height = 0;
        if (typeof style?.width === "number") {
            width = style.width;
        }
        else {
            state.requiresLayoutWidth = true;
            width = state.layout?.get()?.[0] ?? 0;
        }
        if (typeof style?.height === "number") {
            height = style.height;
        }
        else {
            state.requiresLayoutHeight = true;
            height = state.layout?.get()?.[1] ?? 0;
        }
        return { width, height };
    }
}
function getVariable(name) {
    return resolve(signals_1.interopGlobal.current?.state?.getVariable(name));
}
const defaultAnimation = {
    name: [],
    direction: ["normal"],
    fillMode: ["none"],
    iterationCount: [{ type: "number", value: 1 }],
    timingFunction: [{ type: "linear" }],
    playState: ["running"],
    duration: [{ type: "seconds", value: 0 }],
    delay: [{ type: "seconds", value: 0 }],
};
const defaultTransition = {
    property: [],
    duration: [{ type: "seconds", value: 0 }],
    delay: [{ type: "seconds", value: 0 }],
    timingFunction: [{ type: "linear" }],
};
exports.defaultValues = {
    backgroundColor: "transparent",
    borderBottomColor: "transparent",
    borderBottomLeftRadius: 0,
    borderBottomRightRadius: 0,
    borderBottomWidth: 0,
    borderColor: "transparent",
    borderLeftColor: "transparent",
    borderLeftWidth: 0,
    borderRadius: 0,
    borderRightColor: "transparent",
    borderRightWidth: 0,
    borderTopColor: "transparent",
    borderTopWidth: 0,
    borderWidth: 0,
    bottom: 0,
    color: () => {
        return globals_1.colorScheme.get() === "dark" ? "white" : "black";
    },
    flex: 1,
    flexBasis: 1,
    flexGrow: 1,
    flexShrink: 0,
    fontSize: 14,
    fontWeight: "400",
    gap: 0,
    left: 0,
    lineHeight: 14,
    margin: 0,
    marginBottom: 0,
    marginLeft: 0,
    marginRight: 0,
    marginTop: 0,
    maxHeight: 99999,
    maxWidth: 99999,
    minHeight: 0,
    minWidth: 0,
    opacity: 1,
    padding: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    paddingTop: 0,
    perspective: 1,
    right: 0,
    rotate: "0deg",
    rotateX: "0deg",
    rotateY: "0deg",
    rotateZ: "0deg",
    scale: 1,
    scaleX: 1,
    scaleY: 1,
    skewX: "0deg",
    skewY: "0deg",
    top: 0,
    translateX: 0,
    translateY: 0,
    zIndex: 0,
};
function deepEqual(obj1, obj2) {
    if (obj1 === obj2)
        return true;
    if (isPrimitive(obj1) && isPrimitive(obj2))
        return obj1 === obj2;
    if (Object.keys(obj1).length !== Object.keys(obj2).length)
        return false;
    for (let key in obj1) {
        if (!(key in obj2))
            return false;
        if (!deepEqual(obj1[key], obj2[key]))
            return false;
    }
    return true;
}
function isPrimitive(obj) {
    return obj !== Object(obj);
}
function resolveObject(obj) {
    for (var i in obj) {
        const v = obj[i];
        if (typeof v == "object" && v != null)
            resolveObject(v);
        else
            obj[i] = typeof v === "function" ? v() : v;
    }
}
function getEasing(timingFunction) {
    switch (timingFunction.type) {
        case "ease":
            return react_native_reanimated_1.Easing.ease;
        case "ease-in":
            return react_native_reanimated_1.Easing.in(react_native_reanimated_1.Easing.quad);
        case "ease-out":
            return react_native_reanimated_1.Easing.out(react_native_reanimated_1.Easing.quad);
        case "ease-in-out":
            return react_native_reanimated_1.Easing.inOut(react_native_reanimated_1.Easing.quad);
        case "linear":
            return react_native_reanimated_1.Easing.linear;
        case "cubic-bezier":
            return react_native_reanimated_1.Easing.bezier(timingFunction.x1, timingFunction.y1, timingFunction.x2, timingFunction.y2);
        default:
            return react_native_reanimated_1.Easing.linear;
    }
}
//# sourceMappingURL=style.js.map