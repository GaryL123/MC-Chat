"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAnimatedComponent = exports.CSSInteropAnimationWrapper = exports.defaultCSSInterop = void 0;
const react_1 = require("react");
const react_native_1 = require("react-native");
const react_native_reanimated_1 = __importStar(require("react-native-reanimated"));
const style_1 = require("./style");
const globals_1 = require("./globals");
const conditions_1 = require("./conditions");
const defaultCSSInterop = (component, options, originalProps, children) => {
    let props = { ...originalProps, children };
    const parent = (0, react_1.useContext)(globals_1.interopContext);
    const storeRef = (0, react_1.useRef)();
    if (!storeRef.current) {
        storeRef.current = (0, style_1.createInteropStore)(parent, options, props);
    }
    const state = storeRef.current.state;
    (0, react_1.useSyncExternalStore)(storeRef.current.subscribe, storeRef.current.snapshot, storeRef.current.snapshot);
    if (parent !== state.parent ||
        options.dependencies.some((k, i) => props[k] !== state.dependencies[i]) ||
        storeRef.current.state.attrDependencies.some((condition) => {
            return (0, conditions_1.getTestAttributeValue)(props, condition) !== condition.previous;
        })) {
        state.rerender(parent, props);
    }
    props = {
        ...props,
        ...state.props,
    };
    for (const source of options.sources) {
        delete props[source];
    }
    if (state.convertToPressable) {
        if (component === react_native_1.View) {
            props.___pressable = true;
            component = react_native_1.Pressable;
        }
    }
    if (state.isAnimated) {
        const $component = createAnimatedComponent(component);
        props.__component = $component;
        component = CSSInteropAnimationWrapper;
    }
    if (state.context) {
        children = (0, react_1.createElement)(component, props, children);
        props = { value: state.context };
        component = globals_1.InteropProvider;
    }
    return (0, react_1.createElement)(component, props, children);
};
exports.defaultCSSInterop = defaultCSSInterop;
function CSSInteropAnimationWrapper({ __component: Component, __sharedValues, ...props }) {
    const style = (0, react_native_reanimated_1.useAnimatedStyle)(() => {
        const style = {};
        const entries = Object.entries(props.style);
        for (const [key, value] of entries) {
            if (typeof value === "object" && "value" in value) {
                style[key] = value.value;
            }
            else if (key === "transform") {
                style.transform = value.map((v) => {
                    const [key, value] = Object.entries(v)[0];
                    if (typeof value === "object" && "value" in value) {
                        return { [key]: value.value };
                    }
                    else {
                        return { [key]: value };
                    }
                });
            }
            else {
                style[key] = value;
            }
        }
        return style;
    }, [props.style]);
    return (0, react_1.createElement)(Component, { ...props, style }, props.children);
}
exports.CSSInteropAnimationWrapper = CSSInteropAnimationWrapper;
const animatedCache = new Map();
function createAnimatedComponent(Component) {
    if (animatedCache.has(Component)) {
        return animatedCache.get(Component);
    }
    else if (Component.displayName?.startsWith("AnimatedComponent")) {
        return Component;
    }
    if (!(typeof Component !== "function" ||
        (Component.prototype && Component.prototype.isReactComponent))) {
        throw new Error(`Looks like you're passing an animation style to a function component \`${Component.name}\`. Please wrap your function component with \`React.forwardRef()\` or use a class component instead.`);
    }
    const AnimatedComponent = react_native_reanimated_1.default.createAnimatedComponent(Component);
    animatedCache.set(Component, AnimatedComponent);
    return AnimatedComponent;
}
exports.createAnimatedComponent = createAnimatedComponent;
//# sourceMappingURL=interop.js.map