"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useComputed = exports.createComputed = exports.cleanupEffect = exports.setupEffect = exports.createSignal = exports.context = exports.interopGlobal = void 0;
const react_1 = require("react");
exports.interopGlobal = {
    isInComponent: false,
    current: null,
    delayedEvents: new Set(),
};
exports.context = [];
function createSignal(value, id) {
    const signal = {
        subscriptions: new Set(),
        get() {
            const running = exports.context[exports.context.length - 1];
            if (running) {
                signal.subscriptions.add(running);
                running.dependencies.add(signal);
            }
            return value;
        },
        id,
        peek() {
            return value;
        },
        set(nextValue) {
            if (typeof nextValue === "function") {
                nextValue = nextValue(value);
            }
            if (Object.is(value, nextValue))
                return;
            value = nextValue;
            if (exports.interopGlobal.isInComponent) {
                for (const sub of signal.subscriptions) {
                    exports.interopGlobal.delayedEvents.add(sub);
                }
            }
            else {
                for (const sub of Array.from(signal.subscriptions)) {
                    sub();
                }
            }
        },
        subscribe(callback) {
            signal.subscriptions.add(callback);
            return () => signal.unsubscribe(callback);
        },
        unsubscribe(callback) {
            signal.subscriptions.delete(callback);
        },
    };
    return signal;
}
exports.createSignal = createSignal;
function setupEffect(effect) {
    cleanupEffect(effect);
    exports.context.push(effect);
    exports.interopGlobal.delayedEvents.delete(effect);
    exports.interopGlobal.current = effect;
}
exports.setupEffect = setupEffect;
function teardown(_effect) {
    exports.context.pop();
}
function cleanupEffect(effect) {
    for (const dep of effect.dependencies) {
        if ("subscriptions" in dep) {
            dep.subscriptions.delete(effect);
        }
    }
    effect.dependencies.clear();
    exports.interopGlobal.delayedEvents.delete(effect);
}
exports.cleanupEffect = cleanupEffect;
function createComputed(fn, runOnInitialization = true, id) {
    const effect = Object.assign(function () {
        setupEffect(effect);
        effect.set(effect.fn);
        teardown(effect);
    }, createSignal(undefined, id), {
        dependencies: new Set(),
        fn: fn,
        runInEffect(fn) {
            exports.context.push(effect);
            let value = fn();
            exports.context.pop();
            return value;
        },
    });
    if (runOnInitialization) {
        effect();
    }
    return effect;
}
exports.createComputed = createComputed;
function useComputed(fn, dependency) {
    const [{ computed, dependency: lastDependency }, dispatch] = (0, react_1.useReducer)((state, action) => {
        return { ...state, ...action };
    }, undefined, () => {
        return {
            computed: createComputed(fn),
            dependency,
        };
    });
    (0, react_1.useEffect)(() => {
        const sub = computed.subscribe(() => {
            dispatch({});
        });
        return () => sub();
    }, [computed]);
    (0, react_1.useEffect)(() => {
        if (exports.interopGlobal.delayedEvents.size) {
            for (const sub of exports.interopGlobal.delayedEvents) {
                sub();
            }
            exports.interopGlobal.delayedEvents.clear();
        }
    });
    if (dependency != lastDependency) {
        dispatch({
            computed: createComputed(fn),
            dependency,
        });
    }
    return computed.peek();
}
exports.useComputed = useComputed;
//# sourceMappingURL=signals.js.map