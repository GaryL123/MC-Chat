"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withNativeWind = void 0;
const loadConfig_1 = __importDefault(require("tailwindcss/loadConfig"));
const package_json_1 = __importDefault(require("tailwindcss/package.json"));
const micromatch_1 = __importDefault(require("micromatch"));
const path_1 = __importDefault(require("path"));
const metro_1 = require("react-native-css-interop/metro");
const common_1 = require("./common");
const tailwind_cli_1 = require("./tailwind-cli");
function withNativeWind(metroConfig, { input, outputDir = ["node_modules", ".cache", "nativewind"].join(path_1.default.sep), projectRoot = process.cwd(), inlineRem = 14, configPath: tailwindConfigPath = "tailwind.config.js", cliCommand = `node ${path_1.default.join(require.resolve("tailwindcss/package.json"), "../", package_json_1.default.bin.tailwindcss)}`, hotServerOptions = {}, browserslist = "last 1 version", browserslistEnv = "native", experiments, } = {}) {
    if (!input) {
        throw new Error("withNativeWind requires an input parameter: `withNativeWind(config, { input: <css-file> })`");
    }
    input = path_1.default.resolve(input);
    const { important: importantConfig, content } = (0, loadConfig_1.default)(path_1.default.resolve(tailwindConfigPath));
    const contentArray = "files" in content ? content.files : content;
    metroConfig = (0, metro_1.withCssInterop)(metroConfig, {
        ...common_1.cssToReactNativeRuntimeOptions,
        inlineRem,
        experiments,
        selectorPrefix: typeof importantConfig === "string" ? importantConfig : undefined,
    });
    metroConfig.transformerPath = require.resolve("./transformer");
    const tailwindHasStarted = {
        native: false,
        web: false,
    };
    const previousTransformOptions = metroConfig.transformer?.getTransformOptions;
    metroConfig.transformer = {
        ...metroConfig.transformer,
        nativewind: {
            input,
            experiments,
        },
        getTransformOptions: async (entryPoints, options, getDependenciesOf) => {
            const output = path_1.default.resolve(projectRoot, path_1.default.join(outputDir, path_1.default.basename(input)));
            const matchesOutputDir = contentArray.some((pattern) => {
                if (typeof pattern !== "string")
                    return false;
                return micromatch_1.default.isMatch(output, pattern);
            });
            if (matchesOutputDir) {
                throw new Error(`NativeWind: Your '${tailwindConfigPath}#content' includes the output file ${output} which will cause an infinite loop. Please read https://tailwindcss.com/docs/content-configuration#styles-rebuild-in-an-infinite-loop`);
            }
            if (process.stdout.isTTY) {
                process.stdout.clearLine(0);
                process.stdout.cursorTo(0);
            }
            const platform = options.platform === "web" ? "web" : "native";
            if (!tailwindHasStarted[platform]) {
                tailwindHasStarted[platform] = true;
                const cliOutput = await (0, tailwind_cli_1.tailwindCli)(input, metroConfig, {
                    ...options,
                    output,
                    cliCommand,
                    hotServerOptions,
                    browserslist,
                    browserslistEnv,
                });
                if (cliOutput) {
                    Object.assign(metroConfig.transformer.nativewind, cliOutput);
                }
            }
            return previousTransformOptions?.(entryPoints, options, getDependenciesOf);
        },
    };
    return metroConfig;
}
exports.withNativeWind = withNativeWind;
//# sourceMappingURL=index.js.map