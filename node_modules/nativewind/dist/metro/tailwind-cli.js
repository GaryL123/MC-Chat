"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tailwindCli = void 0;
const node_net_1 = __importDefault(require("node:net"));
const node_child_process_1 = require("node:child_process");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const ws_1 = require("ws");
const css_to_rn_1 = require("react-native-css-interop/css-to-rn");
const common_1 = require("./common");
async function tailwindCli(input, metroConfig, options) {
    let done;
    let reject = () => { };
    let nativewindOptions = {};
    const deferred = new Promise((resolve, _reject) => {
        done = resolve;
        reject = _reject;
    });
    const env = {
        ...process.env,
        NATIVEWIND_NATIVE: options.platform !== "web" ? "1" : undefined,
        BROWSERSLIST: options.browserslist ?? undefined,
        BROWSERSLIST_ENV: options.browserslistEnv ?? undefined,
    };
    const platform = options.platform === "web" ? "web" : "native";
    process.stdout.write(`tailwindcss(${platform}) rebuilding... `);
    const timeout = setTimeout(() => {
        if (options.dev && !process.env.CI) {
            console.warn(`tailwindcss(${platform}) is taking a long time to build, please read https://tailwindcss.com/docs/content-configuration#pattern-recommendations to speed up your build time`);
        }
        reject();
    }, 60000);
    (0, node_fs_1.mkdirSync)((0, node_path_1.dirname)(options.output), { recursive: true });
    const output = (0, common_1.getOutput)(options.output, options);
    const spawnCommands = [
        ...options.cliCommand.split(" "),
        "--input",
        `"${input}"`,
        "--output",
        `"${output}"`,
    ];
    let latestStat;
    let latestStyleData = "{}";
    let version = 0;
    let startedWSServer = false;
    const connections = new Map();
    if (options.dev && options.hot) {
        spawnCommands.push("--watch");
        if (options.platform !== "web") {
            startedWSServer = true;
            if (!options.hotServerOptions.port) {
                options.hotServerOptions.port = await getAvailablePort();
            }
            nativewindOptions.fastRefreshPort = options.hotServerOptions.port;
            const wss = new ws_1.Server(options.hotServerOptions);
            wss.on("connection", (ws) => {
                connections.set(ws, version);
                ws.on("close", () => connections.delete(ws));
                ws.send(latestStyleData);
            });
        }
    }
    try {
        const [command, ...args] = spawnCommands;
        const cli = (0, node_child_process_1.spawn)(command, args, {
            shell: true,
            env,
            windowsVerbatimArguments: true,
            windowsHide: true,
        });
        cli.on("error", (error) => reject());
        cli.stderr.on("data", (data) => {
            data = data.toString();
            if (data.includes("tailwindcss/lib/cli") || data.includes("npm ERR!")) {
                reject();
            }
            if (data.includes("warn - ")) {
                console.warn(data);
                return;
            }
            if (data.startsWith("Specified input file")) {
                console.log("");
                console.error(data);
                clearTimeout(timeout);
                return;
            }
            if (!data.includes("Done in"))
                return;
            nativewindOptions.rawOutput = (0, node_fs_1.readFileSync)(output, "utf-8");
            nativewindOptions.outputPath = output;
            if (startedWSServer) {
                const stat = (0, node_fs_1.statSync)(output);
                if (stat.mtimeMs === latestStat?.mtimeMs)
                    return;
                latestStat = stat;
                version = version + 1;
                latestStyleData = JSON.stringify((0, css_to_rn_1.cssToReactNativeRuntime)(nativewindOptions.rawOutput, metroConfig.transformer.cssToReactNativeRuntime));
                nativewindOptions.parsedOutput = latestStyleData;
                for (const [ws, lastVersion] of connections) {
                    if (lastVersion !== version) {
                        ws.send(latestStyleData);
                        connections.set(ws, version);
                    }
                }
            }
            clearTimeout(timeout);
            done(nativewindOptions);
        });
    }
    catch {
        reject();
    }
    return deferred
        .then((data) => {
        console.log("done");
        return data;
    })
        .catch(() => {
        console.error("\nError running TailwindCSS CLI, please run the CLI manually to see the error.");
        console.error("Command used: ", ...spawnCommands);
        process.exit(1);
    });
}
exports.tailwindCli = tailwindCli;
async function getAvailablePort(port = 8089) {
    return checkAvailablePort(port).catch(() => getAvailablePort(port + 1));
}
function checkAvailablePort(port) {
    return new Promise((resolve, reject) => {
        const server = node_net_1.default.createServer();
        server.unref();
        server.on("error", reject);
        server.listen({ port }, () => {
            const { port } = server.address();
            server.close(() => {
                resolve(port);
            });
        });
    });
}
//# sourceMappingURL=tailwind-cli.js.map